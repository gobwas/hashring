// Code generated by gtrace. DO NOT EDIT.

// +build !trace

package hashring

// Compose returns a new traceRing which has functional fields composed
// both from t and x.
func (t traceRing) Compose(x traceRing) (ret traceRing) {
	switch {
	case t.OnInsert == nil:
		ret.OnInsert = x.OnInsert
	case x.OnInsert == nil:
		ret.OnInsert = t.OnInsert
	default:
		h1 := t.OnInsert
		h2 := x.OnInsert
		ret.OnInsert = func(p *point) traceRingInsert {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1.isZero():
				return r2
			case r2.isZero():
				return r1
			default:
				return r1.Compose(r2)
			}
		}
	}
	switch {
	case t.OnDelete == nil:
		ret.OnDelete = x.OnDelete
	case x.OnDelete == nil:
		ret.OnDelete = t.OnDelete
	default:
		h1 := t.OnDelete
		h2 := x.OnDelete
		ret.OnDelete = func(p *point) traceRingDelete {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1.isZero():
				return r2
			case r2.isZero():
				return r1
			default:
				return r1.Compose(r2)
			}
		}
	}
	switch {
	case t.OnFix == nil:
		ret.OnFix = x.OnFix
	case x.OnFix == nil:
		ret.OnFix = t.OnFix
	default:
		h1 := t.OnFix
		h2 := x.OnFix
		ret.OnFix = func(p *point) traceRingFix {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1.isZero():
				return r2
			case r2.isZero():
				return r1
			default:
				return r1.Compose(r2)
			}
		}
	}
	switch {
	case t.OnFixNeeded == nil:
		ret.OnFixNeeded = x.OnFixNeeded
	case x.OnFixNeeded == nil:
		ret.OnFixNeeded = t.OnFixNeeded
	default:
		h1 := t.OnFixNeeded
		h2 := x.OnFixNeeded
		ret.OnFixNeeded = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	return ret
}
var gtraceNoopTraceRingInsert960df076 traceRingInsert
func (traceRing) onInsert(*point) traceRingInsert {
	return gtraceNoopTraceRingInsert960df076
}
var gtraceNoopTraceRingDelete58d9e55d traceRingDelete
func (traceRing) onDelete(*point) traceRingDelete {
	return gtraceNoopTraceRingDelete58d9e55d
}
var gtraceNoopTraceRingFix30bafeaa traceRingFix
func (traceRing) onFix(*point) traceRingFix {
	return gtraceNoopTraceRingFix30bafeaa
}
func (traceRing) onFixNeeded(*point) {
}
// Compose returns a new traceRingInsert which has functional fields composed
// both from t and x.
func (t traceRingInsert) Compose(x traceRingInsert) (ret traceRingInsert) {
	switch {
	case t.OnDone == nil:
		ret.OnDone = x.OnDone
	case x.OnDone == nil:
		ret.OnDone = t.OnDone
	default:
		h1 := t.OnDone
		h2 := x.OnDone
		ret.OnDone = func(b bool) {
			h1(b)
			h2(b)
		}
	}
	switch {
	case t.OnCollision == nil:
		ret.OnCollision = x.OnCollision
	case x.OnCollision == nil:
		ret.OnCollision = t.OnCollision
	default:
		h1 := t.OnCollision
		h2 := x.OnCollision
		ret.OnCollision = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	return ret
}
// isZero checks whether t is empty
func (t traceRingInsert) isZero() bool {
	if t.OnDone != nil {
		return false
	}
	if t.OnCollision != nil {
		return false
	}
	return true
}
func (traceRingInsert) onDone(bool) {
}
func (traceRingInsert) onCollision(*point) {
}
// Compose returns a new traceRingDelete which has functional fields composed
// both from t and x.
func (t traceRingDelete) Compose(x traceRingDelete) (ret traceRingDelete) {
	switch {
	case t.OnDone == nil:
		ret.OnDone = x.OnDone
	case x.OnDone == nil:
		ret.OnDone = t.OnDone
	default:
		h1 := t.OnDone
		h2 := x.OnDone
		ret.OnDone = func(b bool) {
			h1(b)
			h2(b)
		}
	}
	switch {
	case t.OnProcessing == nil:
		ret.OnProcessing = x.OnProcessing
	case x.OnProcessing == nil:
		ret.OnProcessing = t.OnProcessing
	default:
		h1 := t.OnProcessing
		h2 := x.OnProcessing
		ret.OnProcessing = func(p *point) func() {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1 == nil:
				return r2
			case r2 == nil:
				return r1
			default:
				return func() {
					r1()
					r2()
				}
			}
		}
	}
	switch {
	case t.OnTwinDelete == nil:
		ret.OnTwinDelete = x.OnTwinDelete
	case x.OnTwinDelete == nil:
		ret.OnTwinDelete = t.OnTwinDelete
	default:
		h1 := t.OnTwinDelete
		h2 := x.OnTwinDelete
		ret.OnTwinDelete = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	switch {
	case t.OnTwinRestore == nil:
		ret.OnTwinRestore = x.OnTwinRestore
	case x.OnTwinRestore == nil:
		ret.OnTwinRestore = t.OnTwinRestore
	default:
		h1 := t.OnTwinRestore
		h2 := x.OnTwinRestore
		ret.OnTwinRestore = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	return ret
}
// isZero checks whether t is empty
func (t traceRingDelete) isZero() bool {
	if t.OnDone != nil {
		return false
	}
	if t.OnProcessing != nil {
		return false
	}
	if t.OnTwinDelete != nil {
		return false
	}
	if t.OnTwinRestore != nil {
		return false
	}
	return true
}
func (traceRingDelete) onDone(bool) {
}
func gtraceNoopB077713e() {
}
func (traceRingDelete) onProcessing(*point) func() {
	return gtraceNoopB077713e
}
func (traceRingDelete) onTwinDelete(*point) {
}
func (traceRingDelete) onTwinRestore(*point) {
}
// Compose returns a new traceRingFix which has functional fields composed
// both from t and x.
func (t traceRingFix) Compose(x traceRingFix) (ret traceRingFix) {
	switch {
	case t.OnDone == nil:
		ret.OnDone = x.OnDone
	case x.OnDone == nil:
		ret.OnDone = t.OnDone
	default:
		h1 := t.OnDone
		h2 := x.OnDone
		ret.OnDone = func() {
			h1()
			h2()
		}
	}
	return ret
}
// isZero checks whether t is empty
func (t traceRingFix) isZero() bool {
	if t.OnDone != nil {
		return false
	}
	return true
}
func (traceRingFix) onDone() {
}
