// Code generated by gtrace. DO NOT EDIT.

// +build trace

package hashring

// Compose returns a new traceRing which has functional fields composed
// both from t and x.
func (t traceRing) Compose(x traceRing) (ret traceRing) {
	switch {
	case t.OnInsert == nil:
		ret.OnInsert = x.OnInsert
	case x.OnInsert == nil:
		ret.OnInsert = t.OnInsert
	default:
		h1 := t.OnInsert
		h2 := x.OnInsert
		ret.OnInsert = func(p *point) traceRingInsert {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1.isZero():
				return r2
			case r2.isZero():
				return r1
			default:
				return r1.Compose(r2)
			}
		}
	}
	switch {
	case t.OnDelete == nil:
		ret.OnDelete = x.OnDelete
	case x.OnDelete == nil:
		ret.OnDelete = t.OnDelete
	default:
		h1 := t.OnDelete
		h2 := x.OnDelete
		ret.OnDelete = func(p *point) traceRingDelete {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1.isZero():
				return r2
			case r2.isZero():
				return r1
			default:
				return r1.Compose(r2)
			}
		}
	}
	switch {
	case t.OnFix == nil:
		ret.OnFix = x.OnFix
	case x.OnFix == nil:
		ret.OnFix = t.OnFix
	default:
		h1 := t.OnFix
		h2 := x.OnFix
		ret.OnFix = func(p *point) traceRingFix {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1.isZero():
				return r2
			case r2.isZero():
				return r1
			default:
				return r1.Compose(r2)
			}
		}
	}
	switch {
	case t.OnFixNeeded == nil:
		ret.OnFixNeeded = x.OnFixNeeded
	case x.OnFixNeeded == nil:
		ret.OnFixNeeded = t.OnFixNeeded
	default:
		h1 := t.OnFixNeeded
		h2 := x.OnFixNeeded
		ret.OnFixNeeded = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	return ret
}
func (t traceRing) onInsert(p *point) traceRingInsert {
	fn := t.OnInsert
	if fn == nil {
		return traceRingInsert{}
	}
	res := fn(p)
	return res
}
func (t traceRing) onDelete(p *point) traceRingDelete {
	fn := t.OnDelete
	if fn == nil {
		return traceRingDelete{}
	}
	res := fn(p)
	return res
}
func (t traceRing) onFix(p *point) traceRingFix {
	fn := t.OnFix
	if fn == nil {
		return traceRingFix{}
	}
	res := fn(p)
	return res
}
func (t traceRing) onFixNeeded(p *point) {
	fn := t.OnFixNeeded
	if fn == nil {
		return
	}
	fn(p)
}
// Compose returns a new traceRingInsert which has functional fields composed
// both from t and x.
func (t traceRingInsert) Compose(x traceRingInsert) (ret traceRingInsert) {
	switch {
	case t.OnDone == nil:
		ret.OnDone = x.OnDone
	case x.OnDone == nil:
		ret.OnDone = t.OnDone
	default:
		h1 := t.OnDone
		h2 := x.OnDone
		ret.OnDone = func(b bool) {
			h1(b)
			h2(b)
		}
	}
	switch {
	case t.OnCollision == nil:
		ret.OnCollision = x.OnCollision
	case x.OnCollision == nil:
		ret.OnCollision = t.OnCollision
	default:
		h1 := t.OnCollision
		h2 := x.OnCollision
		ret.OnCollision = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	return ret
}
// isZero checks whether t is empty
func (t traceRingInsert) isZero() bool {
	if t.OnDone != nil {
		return false
	}
	if t.OnCollision != nil {
		return false
	}
	return true
}
func (t traceRingInsert) onDone(b bool) {
	fn := t.OnDone
	if fn == nil {
		return
	}
	fn(b)
}
func (t traceRingInsert) onCollision(p *point) {
	fn := t.OnCollision
	if fn == nil {
		return
	}
	fn(p)
}
// Compose returns a new traceRingDelete which has functional fields composed
// both from t and x.
func (t traceRingDelete) Compose(x traceRingDelete) (ret traceRingDelete) {
	switch {
	case t.OnDone == nil:
		ret.OnDone = x.OnDone
	case x.OnDone == nil:
		ret.OnDone = t.OnDone
	default:
		h1 := t.OnDone
		h2 := x.OnDone
		ret.OnDone = func(b bool) {
			h1(b)
			h2(b)
		}
	}
	switch {
	case t.OnProcessing == nil:
		ret.OnProcessing = x.OnProcessing
	case x.OnProcessing == nil:
		ret.OnProcessing = t.OnProcessing
	default:
		h1 := t.OnProcessing
		h2 := x.OnProcessing
		ret.OnProcessing = func(p *point) func() {
			r1 := h1(p)
			r2 := h2(p)
			switch {
			case r1 == nil:
				return r2
			case r2 == nil:
				return r1
			default:
				return func() {
					r1()
					r2()
				}
			}
		}
	}
	switch {
	case t.OnTwinDelete == nil:
		ret.OnTwinDelete = x.OnTwinDelete
	case x.OnTwinDelete == nil:
		ret.OnTwinDelete = t.OnTwinDelete
	default:
		h1 := t.OnTwinDelete
		h2 := x.OnTwinDelete
		ret.OnTwinDelete = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	switch {
	case t.OnTwinRestore == nil:
		ret.OnTwinRestore = x.OnTwinRestore
	case x.OnTwinRestore == nil:
		ret.OnTwinRestore = t.OnTwinRestore
	default:
		h1 := t.OnTwinRestore
		h2 := x.OnTwinRestore
		ret.OnTwinRestore = func(p *point) {
			h1(p)
			h2(p)
		}
	}
	return ret
}
// isZero checks whether t is empty
func (t traceRingDelete) isZero() bool {
	if t.OnDone != nil {
		return false
	}
	if t.OnProcessing != nil {
		return false
	}
	if t.OnTwinDelete != nil {
		return false
	}
	if t.OnTwinRestore != nil {
		return false
	}
	return true
}
func (t traceRingDelete) onDone(b bool) {
	fn := t.OnDone
	if fn == nil {
		return
	}
	fn(b)
}
func (t traceRingDelete) onProcessing(p *point) func() {
	fn := t.OnProcessing
	if fn == nil {
		return func() {
			return
		}
	}
	res := fn(p)
	if res == nil {
		return func() {
			return
		}
	}
	return res
}
func (t traceRingDelete) onTwinDelete(p *point) {
	fn := t.OnTwinDelete
	if fn == nil {
		return
	}
	fn(p)
}
func (t traceRingDelete) onTwinRestore(p *point) {
	fn := t.OnTwinRestore
	if fn == nil {
		return
	}
	fn(p)
}
// Compose returns a new traceRingFix which has functional fields composed
// both from t and x.
func (t traceRingFix) Compose(x traceRingFix) (ret traceRingFix) {
	switch {
	case t.OnDone == nil:
		ret.OnDone = x.OnDone
	case x.OnDone == nil:
		ret.OnDone = t.OnDone
	default:
		h1 := t.OnDone
		h2 := x.OnDone
		ret.OnDone = func() {
			h1()
			h2()
		}
	}
	return ret
}
// isZero checks whether t is empty
func (t traceRingFix) isZero() bool {
	if t.OnDone != nil {
		return false
	}
	return true
}
func (t traceRingFix) onDone() {
	fn := t.OnDone
	if fn == nil {
		return
	}
	fn()
}
